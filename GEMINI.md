# Проект "ФинТвист" – Ваш финансовый ассистент

## 1. О проекте

### 1.1. Тематика проекта
Цифровая трансформация в области управления личными финансами.

### 1.2. Название проекта
ФинТвист

### 1.3. Краткое описание проекта
"ФинТвист" — это сервис, который берет на себя всю рутину учета финансов. Пользователь просто тратит деньги, а система автоматически собирает данные, анализирует их и выдает готовые решения. Проект не просто констатирует факты ("Вы много тратите на доставку"), а предлагает конкретный план действий: как сократить определенную статью расходов и на чем сэкономить именно в вашем случае. Это как личный финансовый консультант в кармане, работающий 24/7.

### 1.4. Описание проблемы/актуальности проекта
Многие люди регулярно тратят деньги, но не видят полной картины: на что именно уходит бюджет, какие категории расходов превышают остальные и где есть лишние траты. Ручной учет неудобен и требует дисциплины, поэтому большинство быстро перестает вести таблицы или записи. Актуальность проекта связана с ростом безналичных платежей и подписок: траты происходят часто и незаметно, а небольшие суммы со временем превращаются в значительные расходы. Нужен инструмент, который не только фиксирует траты, но и помогает понять их структуру и оптимизировать бюджет. "ФинТвист" собирает статистику расходов клиента, структурирует данные по категориям и периодам, показывает динамику и формирует рекомендации по экономии. Это помогает пользователю лучше контролировать финансы и достигать финансовых целей.

### 1.5. Целевая аудитория
Основная целевая аудитория проекта – студенты и школьники. Для них важна простота использования, интуитивно понятный интерфейс и актуальный для их образа жизни стиль общения бота. Особенности этой аудитории будут учтены при разработке категорий расходов и формулировании рекомендаций.

### 1.6. Основная цель проекта (SMART-цель)
**К концу 2025 года, 30% активных пользователей "ФинТвист" сократят свои необязательные расходы на 10% благодаря персонализированным рекомендациям сервиса.**
Эта цель является **конкретной** (сокращение необязательных расходов), **измеримой** (30% пользователей, 10% сокращение), **достижимой** (ориентир на рекомендации), **значимой** (прямо влияет на финансовое состояние пользователей) и **ограниченной во времени** (к концу 2025 года).

### 1.7. Ключевые показатели успеха

*   **Количество активных пользователей:** Ежедневная/еженедельная активность пользователей.
*   **Процент пользователей, сокративших расходы:** Доля пользователей, демонстрирующих снижение трат в целевых категориях после получения рекомендаций.
*   **Средняя экономия на пользователя:** Рассчитывается как среднее снижение расходов в целевых категориях.
*   **Частота использования сервиса:** Как часто пользователи взаимодействуют с ботом (вводят траты, запрашивают аналитику).
*   **Уровень автоматической категоризации:** Процент трат, которые были корректно отнесены к категории без ручного вмешательства.
*   **Удовлетворенность пользователей рекомендациями:** Оценка полезности и применимости полученных советов.

### 1.8. Уникальность проекта (УТП)
**Полностью бесплатный** и простой в обращении сервис, использующий продвинутые возможности большой языковой модели (**LLM**) для персонализированной аналитики и рекомендаций.
Проект является полностью бесплатным (без подписок, платных функций и рекламы). Финансирование на данном этапе не предусмотрено, проект реализуется на энтузиазме команды.

## 2. Функциональные возможности

### 2.1. Ввод и сбор данных о тратах
*   **Распознавание чеков:** Пользователь сможет отправлять фотографии чеков. Система будет использовать облачные сервисы **OCR** (например, Google Vision API или аналогичные) для извлечения информации о покупках, суммах и категориях товаров.
*   **Ручной ввод:** Возможность быстрого ручного ввода трат (например, "картошка 300", "пиво 600").
*   **Автоматическая категоризация:** Система автоматически распределяет траты по категориям на основе данных из чеков или ручного ввода.

### 2.2. Управление категориями расходов
*   **Базовые категории:** Предоставляется набор стандартных категорий (еда, транспорт, развлечения и т.д.).
*   **Настраиваемые категории:** Пользователь может добавлять собственные категории, давать им описания и правила, по которым **LLM** должна будет туда относить траты.
*   **Объединение категорий:** Возможность объединять две или более существующих категорий в одну.
*   **Разделение категорий:** Возможность разбивать крупные категории на более мелкие.
*   **LLM-управление категориями:** **LLM** будет интерпретировать запросы пользователя по созданию/объединению категорий, используя предоставленные описания или правила.

### 2.3. Аналитика и персонализированные рекомендации
*   **Обзор расходов:** Ежедневные/еженедельные/ежемесячные отчеты о тратах по категориям.
*   **Динамика расходов:** Графики, показывающие, как менялись траты в разных категориях со временем.
*   **Бюджетирование:** Возможность установки лимитов по категориям и уведомления о приближении/превышении лимита.
*   **Персонализированные рекомендации:** На основе анализа трат **LLM** будет формировать конкретные советы по экономии, предлагать альтернативы или способы сокращения расходов в определенных категориях. Например, если пользователь часто тратит на доставку еды, **LLM** может предложить рецепты простых блюд для готовки дома.

### 2.4. Взаимодействие с пользователем
Основной канал взаимодействия – бот в Telegram. Дополнительно будет реализовано мини-приложение внутри Telegram для более удобного просмотра аналитики и управления настройками.

## 3. Технологический стек

### 3.1. Основные технологии
*   **Язык программирования:** Python 3.9+
*   **Фреймворк для Telegram-бота:** `python-telegram-bot` или `aiogram`.
*   **Большая языковая модель (LLM):** Использование API готовых LLM (например, Google Gemini API, OpenAI GPT API) для распознавания смысла запросов, категоризации и генерации рекомендаций. Выбор конкретного API будет зависеть от доступности, стоимости (для бесплатного проекта - от бесплатных лимитов/программ поддержки разработчиков) и производительности.
*   **База данных:** PostgreSQL (для надежного хранения данных о пользователях, тратах, категориях).
*   **OCR сервис:** Google Vision API или аналогичный облачный сервис для распознавания текста на чеках.
*   **Веб-фреймворк для мини-приложения (опционально):** FastAPI или Flask для реализации API, с которым будет взаимодействовать мини-приложение Telegram.

### 3.2. Архитектура системы
Предполагается монолитная архитектура на начальном этапе для упрощения разработки и развертывания.

*   **Telegram Бот:** Основной интерфейс для пользователя, обрабатывает команды и текстовые сообщения, принимает фотографии чеков.
*   **Серверная часть (Python):**
    *   Обработка входящих сообщений от бота.
    *   Взаимодействие с **OCR** для распознавания чеков.
    *   Взаимодействие с **LLM** для:
        *   Интерпретации естественного языка пользователя (категоризация, управление категориями, запрос аналитики).
        *   Автоматической категоризации трат.
        *   Генерации персонализированных рекомендаций.
    *   Работа с базой данных (сохранение/извлечение данных о тратах, пользователях, категориях).
    *   Предоставление данных для мини-приложения.
*   **База данных (PostgreSQL):** Хранение всех операционных данных.
*   **Мини-приложение Telegram:** Веб-интерфейс, встроенный в Telegram, для визуализации аналитики и более удобного управления настройками.

### 3.3. Развертывание
Все компоненты проекта будут развернуты на Beelink Ser7, который будет выступать в роли домашнего сервера. При необходимости, для **OCR** и **LLM** будут использоваться облачные API.

## 4. План реализации (Дорожная карта)

Проект будет реализован поэтапно, с акцентом на создание минимально жизнеспособного продукта (**MVP**).

### Фаза 1: Проектирование и Настройка (1-2 недели)
*   **Определение детальных требований:** Уточнение всех функциональных требований и пользовательских сценариев.
*   **Выбор конкретных API:** Финальный выбор **LLM** и **OCR** сервисов, получение ключей доступа.
*   **Настройка окружения:** Установка Python, PostgreSQL, настройка виртуального окружения.
*   **Инициализация Git-репозитория:** Создание репозитория на GitHub, базовая настройка (файл `.gitignore`, `README.md`).
*   **Разделение ролей в команде:** Четкое распределение обязанностей между 4 участниками команды.

### Фаза 2: Разработка Базового Функционала (4-6 недель)
*   **Разработка ядра бота:** Обработка основных команд Telegram, регистрация пользователей.
*   **Интеграция с базой данных:** Модели данных для трат, пользователей, категорий.
*   **Ручной ввод трат:** Реализация функционала для быстрого ручного ввода ("картошка 300").
*   **Базовая автоматическая категоризация:** Первоначальная логика категоризации на основе предопределенных правил и взаимодействия с **LLM** (простейшие запросы).
*   **Интеграция с OCR:** Отправка фотографий чеков в **OCR** сервис и получение распознанного текста.

### Фаза 3: Развитие LLM-функционала и Аналитики (6-8 недель)
*   **Продвинутая категоризация с LLM:** Улучшение точности автоматической категоризации с помощью **LLM**, учет контекста и пользовательских правил.
*   **Управление категориями через LLM:** Реализация добавления/объединения категорий через естественный язык.
*   **Базовая аналитика:** Отчеты о расходах по категориям, графики.
*   **Персонализированные рекомендации:** Первая версия **LLM**-генерируемых советов по экономии.

### Фаза 4: Разработка Мини-приложения и Тестирование (4-6 недель)
*   **Разработка API для мини-приложения:** Создание REST API на FastAPI/Flask для взаимодействия с серверной частью.
*   **Разработка мини-приложения Telegram:** Интерфейс для просмотра аналитики и управления настройками.
*   **Тестирование:** Функциональное, интеграционное, пользовательское тестирование **MVP**.
*   **Сбор обратной связи:** Пилотное использование среди ограниченной группы пользователей.

### Фаза 5: Запуск MVP и дальнейшее развитие
*   **Публикация бота:** Официальный запуск Telegram-бота.
*   **Мониторинг и исправление ошибок:** Отслеживание работы сервиса, оперативное устранение проблем.
*   **Сбор обратной связи:** Регулярный сбор и анализ отзывов пользователей для дальнейшего развития.
*   **Итерационное развитие:** Добавление новых функций, улучшение **LLM**, расширение аналитики.

## 5. Инструкции по работе с Git/GitHub

Git — это система контроля версий, которая помогает отслеживать изменения в коде, работать в команде и возвращаться к предыдущим версиям проекта. GitHub — это платформа для хостинга Git-репозиториев.

### 5.1. Установка Git
Если Git не установлен, скачайте его с официального сайта: [git-scm.com/downloads](https://git-scm.com/downloads)

### 5.2. Настройка Git (один раз)
Откройте терминал и выполните команды, заменив данные на свои:
```bash
git config --global user.name "Ваше Имя"
git config --global user.email "ваш.email@example.com"
```

### 5.3. Создание репозитория на GitHub (лидер команды)
1.  Перейдите на [github.com](https://github.com) и войдите в свой аккаунт.
2.  Нажмите кнопку "New" для создания нового репозитория.
3.  Придумайте имя репозитория (например, `FinTwist`).
4.  Сделайте его "Public" (публичным), чтобы другие участники могли видеть и клонировать его.
5.  Отметьте галочку "Add a README file" и "Add .gitignore" (выберите шаблон для Python).
6.  Нажмите "Create repository".

### 5.4. Клонирование репозитория на локальный компьютер (все участники)
Откройте терминал, перейдите в папку, где хотите хранить проект, и выполните:
```bash
git clone <URL_ВАШЕГО_РЕПОЗИТОРИЯ>
```
URL можно скопировать с GitHub, нажав кнопку "Code" и выбрав "HTTPS".

### 5.5. Основы работы с Git (для новичков)

1.  **Проверка статуса:** `git status` — показывает, какие файлы изменены, добавлены или удалены.
2.  **Добавление файлов для коммита:** `git add .` — добавляет все измененные/новые файлы в "область подготовленных изменений". Можно добавить конкретный файл: `git add <имя_файла>`.
3.  **Создание коммита:** `git commit -m "Подробное описание изменений"` — сохраняет изменения в локальной истории. Сообщение должно быть ясным и отражать суть сделанного.
4.  **Отправка изменений на GitHub:** `git push origin <имя_вашей_ветки>` — отправляет ваши локальные коммиты в удаленный репозиторий на GitHub. Если вы работаете в ветке `main` (или `master`), то `git push origin main`.
5.  **Получение последних изменений с GitHub:** `git pull origin <имя_ветки>` — скачивает и применяет изменения из удаленного репозитория к вашей локальной ветке.

### 5.6. Рабочий процесс для команды (Feature Branch Workflow)

Для командной работы рекомендуется использовать ветки. Каждый участник работает в своей отдельной ветке для каждой новой функции или исправления ошибки.

1.  **Создание новой ветки:**
    ```bash
    git checkout main        # Переключиться на основную ветку
    git pull origin main     # Убедиться, что основная ветка актуальна
    git checkout -b <имя_вашей_ветки> # Создать новую ветку и переключиться на нее
    ```
    Пример имени ветки: `feature/telegram_bot_base`, `fix/ocr_error`.

2.  **Работа над задачей:** Вносите изменения, добавляйте, коммитьте:
    ```bash
    git add .
    git commit -m "Реализован базовый функционал Telegram бота"
    ```

3.  **Отправка ветки на GitHub:**
    ```bash
    git push origin <имя_вашей_ветки>
    ```

4.  **Создание Pull Request (PR):** После завершения задачи перейдите на GitHub. Вы увидите уведомление о вашей новой ветке. Создайте "Pull Request" (запрос на слияние) в ветку `main`. Опишите, что вы сделали. Другие члены команды могут просмотреть код и предложить изменения.

5.  **Слияние Pull Request:** После одобрения, лидер команды (или тот, кто ответственен за слияния) объединяет вашу ветку с `main`.

6.  **Удаление ветки (опционально):** После слияния ветку можно удалить с GitHub и локально:
    ```bash
    git branch -d <имя_вашей_ветки> # Удалить локально (только после слияния)
    ```
    На GitHub ветку можно удалить через интерфейс Pull Request.

## 6. Структура репозитория
Рекомендуемая структура файлов проекта:

```
FinTwist/
├── .git/                      # Служебная папка Git
├── .gitignore                 # Файлы и папки, которые Git должен игнорировать
├── README.md                  # Описание проекта
├── requirements.txt           # Список всех зависимостей Python
├── config/                    # Файлы конфигурации
│   └── __init__.py
│   └── settings.py            # Настройки API-ключей, базы данных и т.д.
├── src/                       # Исходный код проекта
│   ├── __init__.py
│   ├── main.py                # Основной файл запуска бота
│   ├── bot/                   # Логика Telegram-бота
│   │   ├── __init__.py
│   │   ├── handlers.py        # Обработчики команд и сообщений
│   │   └── keyboards.py       # Клавиатуры для бота
│   ├── db/                    # Взаимодействие с базой данных
│   │   ├── __init__.py
│   │   ├── models.py          # Описание моделей данных (SQLAlchemy/Pydantic)
│   │   └── crud.py            # Функции для работы с данными (Create, Read, Update, Delete)
│   ├── llm/                   # Логика работы с LLM
│   │   ├── __init__.py
│   │   ├── llm_service.py     # Модуль для запросов к LLM API
│   │   └── prompts.py         # Шаблоны запросов (промптов) для LLM
│   ├── ocr/                   # Логика работы с OCR
│   │   ├── __init__.py
│   │   └── ocr_service.py     # Модуль для запросов к OCR API
│   ├── core/                  # Основная бизнес-логика (аналитика, категоризация)
│   │   ├── __init__.py
│   │   ├── analytics.py       # Модуль для анализа расходов
│   │   └── categorizer.py     # Модуль для категоризации
│   └── webapp/                # Код для мини-приложения Telegram (если будет отдельный фронтенд)
│       ├── __init__.py
│       ├── api.py             # API для мини-приложения
│       └── static/            # Статические файлы (HTML, CSS, JS)
├── tests/                     # Тесты (будут добавлены позже)
│   └── __init__.py
└── .env                       # Файл для хранения секретов и переменных окружения (НЕ КОММИТИТЬ В GIT!)
```

## 7. Командная работа и распределение ролей

### Роли в команде (предложено на основе паспорта проекта):
*   **Лидер:** **Ненастин Алексей Александрович**
    *   **Функционал:** Общее руководство проектом, координация команды, принятие ключевых решений, управление версиями (**Code Review**, слияние веток), взаимодействие с внешними площадками (если потребуется).
*   **Разработчик (Бэкенд/LLM):** **Ганькин Тимофей Никитич**
    *   **Функционал:** Разработка серверной части на Python, интеграция с базой данных, реализация логики **OCR** и основного взаимодействия с **LLM**, разработка API для мини-приложения.
*   **Исследователь ресурсов / Аналитик (LLM-промты):** **Гогузоков Беслан Асланович**
    *   **Функционал:** Исследование и подбор оптимальных **LLM** и **OCR** сервисов, разработка и тестирование промптов для **LLM** (для категоризации, рекомендаций, управления категориями), анализ интернет-ресурсов и аудитории, сбор и анализ данных.
*   **Аналитик / Тестировщик (Пользовательский опыт):** **Казаков Александр Андреевич**
    *   **Функционал:** Тестирование бота и мини-приложения, сбор обратной связи от пользователей, анализ пользовательского опыта, помощь в формировании требований к рекомендациям и аналитике.

### Взаимодействие в команде:
*   **Регулярные синхронизации:** Короткие встречи для обсуждения прогресса, проблем и планов.
*   **Использование Git:** Каждый работает в своей ветке, создает **Pull Request** для интеграции изменений в основную ветку `main`.
*   **Code Review:** Члены команды просматривают код друг друга перед слиянием, чтобы обеспечить качество и соответствие стандартам.
*   **Документация:** Поддержание актуальности `README.md` и другой внутренней документации.

---

Я создал файл `GEMINI.md` с этим содержанием в папке `/Users/timgank/Fin_Twist`.

**Важное замечание:**
Я запомнил ваш запрос о том, чтобы вызывать **Gemini CLI** в этой папке. Для этого вам нужно будет перейти в папку `/Users/timgank/Fin_Twist` в терминале (или открыть PyCharm в этой папке) и уже оттуда вызывать меня.

Что скажете? Готовы начать "вайбкодить"?
